\section{Base de données incomplétes}

\begin{frame}{Bases de données incomplètes}
    \begin{block}{}
        Incomplétude de la base de données en raison de valeurs manquantes, mais connectées.
        \pause
        \hyphentextcquote{english}[p.1]{reiterSoundSometimesComplete1986}{\textelp{} these nulls represent existing but unknown individuals}
    \end{block}

    \pause

    \begin{multline*}
        \mathcal{D} = \{
        PrescExam(Mia, \textit{x-ray}),\\ExamResult(Mia, \textit{x-ray}, {\color{blue} N_1}), SOSY(Mia, {\color{blue} N_1})
        \}
    \end{multline*}
\end{frame}

\begin{frame}{Cohérence}
    \begin{block}{}
        La cohérence signifie que toutes les données de la base de données doivent être valides selon un ensemble de règles prédéfinies\\~

        \centering $\mathcal{D}$ est
        \only<1,3>{\color{green}Valide}%
        \only<2>{\color{red}Invalide}%
    \end{block}

    \begin{multline*}
        \mathcal{D} = \{
        PrescExam(Mia, \textit{x-ray}), ExamResult(Mia, \textit{x-ray}, \textit{join inflammation})
        \only<3>{,\\{\color{blue}SOSY(Mia, \textit{join inflammation})}}
        \}
    \end{multline*}

    \vfill

    \begin{itemize}
        \item[$c_1$] $PrescExam(X, Y) \to ExamResult(X, Y, Z)$
        \item<only@2,3>[$c_2$] $ExamResult(X, Y, Z) \to SOSY(X, Z)$
    \end{itemize}
\end{frame}

\begin{frame}{Mises à jour}
    \begin{block}{}
        \begin{itemize}
            \item Comment vérifier la cohérence lors d'une mise à jour ?
                  \begin{itemize}
                      \item<only@2-6> Refuser les mises à jour qui ne satisfont pas les contraintes
                      \item<only@3-6> \emph{Mise à jour prioritaire} et s'assurer que les données respectent les contraintes spécifiées
                  \end{itemize}
            \item<only@4-6> Utilisation des contraintes en tant que dépendance génératrice de tuple (TGD)
            \item<only@5-6> Comment gérer les variables existentielles dans les contraintes ?
        \end{itemize}
    \end{block}

    \begin{multline*}
        \mathcal{D} = \{
        PrescExam(Mia, \textit{x-ray})
        \only<6>{,\\ExamResult(Mia, \textit{x-ray}, {\color{blue} N_1}), SOSY(Mia, {\color{blue} N_1})}
        \}\\
    \end{multline*}

    \begin{itemize}
        \item[$c_1$] $PrescExam(X, Y) \to ExamResult(X, Y, Z)$
        \item[$c_2$] $ExamResult(X, Y, Z) \to SOSY(X, Z)$
    \end{itemize}
\end{frame}

\begin{frame}{Simplification}
    \begin{block}{}
        La redondance signifient qu'il existe des informations équivalentes ou plus spécifiques.
        La simplification consiste à éliminer les redondances.

        \[
            \mathcal{D} = \{P(a, b), P(b, c), P(c, d)\}
        \]
    \end{block}
    \vfill
    \begin{center}
        \only<1>{$P(a, N_1)$ est redondant}
        \only<2>{$P(a, N_1), P(N_1, d)$ n'est pas redondant}
        \only<3>{$P(a, N_1), P(N_1, N_2), P(N_2, d)$ est redondant}
    \end{center}
    % \only<3->{\begin{align*}
    %     \only<3->{P(N_1, N_2)            & ~\to~ P(a, b)                      \\}
    %     \only<4->{P(N_1, N_2)            & ~\xcancel{\to}~ P(a, N_2)          \\}
    %     \only<5->{P(N_1, N_2), P(N_2, c) & ~\xcancel{\to}~ P(a, b), P(N_2, c) \\}
    %     \only<6->{P(N_1, N_2), P(N_2, c) & ~\to~ P(a, b), P(b, c)}
    % \end{align*}}
\end{frame}

\begin{frame}{Comment ?}
    \cite{chabinConsistentUpdatingDatabases2020} propose une méthode de mise à jour avec une implémentation en mémoire\\~

    Notre proposition est :
    \begin{itemize}
        \item Incrémentale, nous ne recalculons pas toute la cohérence de la base de données.
        \item Dans la base de données, en utilisant une modélisation optimale des données
        \item Portée par des requêtes, toutes nos méthodes sont basées sur un petit ensemble de requêtes
    \end{itemize}
\end{frame}

\section{Mise à jour incrémentale}
\begin{frame}{Chase}
    \begin{block}{}
        Prendre en compte uniquement l'instanciation des règles données par la mise à jour.
        \begin{itemize}
            \item[$c_1$] $PrescExam(X, Y) \to ExamResult(X, Y, Z)$
            \item[$c_2$] $ExamResult(X, Y, Z) \to SOSY(X, Z)$
        \end{itemize}

        \[ Q_{chase}^{[c]}(X) \leftarrow body(c), \lnot head(c) \]
    \end{block}

    \vfill

    \begin{enumerate}
        \item Insertion de $PrescExam(Diego, RMI)$
              \pause
        \item seule $c_1$ : $PrescExam(Diego, RMI) \to ExamResult(Diego, RMI, Z)$ est déclenchée
              \pause
        \item seule $c_2$ : $ExamResult(Diego, RMI, N_Z), \to SOSY(Diego, N_Z)$ est déclenchée\\
    \end{enumerate}

    % \vfill
    % \pause How to deal with infinite generation of atoms? \pause Null degree
\end{frame}

\begin{frame}{Simplification}
    Lors d'une mise à jour $U$, seuls les atomes $a_i$ respectant l'une des conditions suivantes sont pris en compte et comparés à la base de données $\mathcal{D}$ :
    \vfill
    \begin{enumerate}
        \item $a_i$ est dans $U$ et contient des valeurs nulles
        \pause\vfill
        \item $a_i$ est dans $\mathcal{D}$, a le même symbole de prédicat qu'un atome $a_i'$ dans $U$ et a pour chaque terme une valeur compatible et, équivalente ou moins spécifique
    \end{enumerate}
    \vfill
    \pause
    \begin{columns}
        \begin{column}{.25\textwidth}
            Given $A(a, b)$\\
        \end{column}
        \hfill
        \begin{column}{.25\textwidth}
            \centering
            $B(a, b)$\\ n'est pas compatible
        \end{column}
        \hfill
        \begin{column}{.25\textwidth}
            \centering
            $A(b, c)$\\ n'est pas compatible
        \end{column}
        \hfill
        \begin{column}{.25\textwidth}
            \centering
            $A(a, N_1)$\\ est compatible
        \end{column}
    \end{columns}
\end{frame}

% \begin{frame}{Jeux de données}
%     \centering
%     \begin{tabular}{l|c|c|c|c}
%         Instances              & Nb Atomes   & Nb Nulls    & Nb Règles & Null/Atome ($\tau$) \\
%         \hline
%         \hline
%         $Movie$                & \num{604}   & \num{340}   & \num{12}  & \num{0.56}          \\
%         $GOT$                  & \num{24818} & \num{17232} & \num{32}  & \num{0.69}          \\
%         \hline
%         $Social_{1K}$          & \num{2248}  & \num{190}   & \num{39}  & \num{0.08}          \\
%         $Social_{10K}$         & \num{16559} & \num{1183}  & \num{39}  & \num{0.07}          \\
%         \hline
%         $Social_{10K}^{0N}$    & \num{16559} & \num{0}     & \num{39}  & \num{0.00}          \\
%         $Social_{10K}^{50N}$   & \num{16559} & \num{50}    & \num{39}  & \num{0.00}          \\
%         $Social_{10K}^{100N}$  & \num{16559} & \num{100}   & \num{39}  & \num{0.01}          \\
%         $Social_{10K}^{500N}$  & \num{16559} & \num{500}   & \num{39}  & \num{0.03}          \\
%         $Social_{10K}^{1000N}$ & \num{16559} & \num{1000}  & \num{39}  & \num{0.06}          \\
%     \end{tabular}
% \end{frame}

\begin{frame}{Évaluation : Temps d'exécution par \acrshort{sgbd}}
    \centering
    \begin{tikzpicture}
        \begin{axis}[xbar, every axis plot/.append style={fill}, axis x line=none, axis line style={draw=none}, tick style={draw=none}, symbolic y coords = {MySQL}, enlarge y limits = 0.5, restrict x to domain=0:*, nodes near coords, ytick=data, xlabel={Temps}, x unit=\si{\ms}, legend columns=-1, legend style={draw=none, at={(0.5,0)}, anchor=north}, width=.9\linewidth, height=.9\textheight]
            \addplot+[area legend] table [y=db, x=chase, col sep=comma] {time_mysql.csv};
            \addlegendentry{Chase};

            \addplot+[area legend] table [y=db, x=nullBucket, col sep=comma] {time_mysql.csv};
            \addlegendentry{Null bucket};

            \addplot+[area legend] table [y=db, x=partitions, col sep=comma, col sep=comma] {time_mysql.csv};
            \addlegendentry{LinkedNulls};

            \addplot+[area legend] table [y=db, x=simplifications, col sep=comma] {time_mysql.csv};
            \addlegendentry{Simplifications};
        \end{axis}
    \end{tikzpicture}
\end{frame}

% \section{Using graphs}

\begin{frame}{Les graphes comme solution ?}
    \centering
    \begin{adjustbox}{width=.8\textwidth}
        \begin{tikzpicture}[shorten >=3pt,->,node distance=16em,on grid,every text node part/.style={align=center}]
            \node[draw] (a) {\textbf{:Atom}\\\textit{symbol}: $P$\\\textit{terms}: $\{t_1, \dots, t_n\}$};        % Atom
            \node[draw,circle,left = of a] (nc) {\textbf{:Element}\\\textbf{:Constant}\\\textit{value}: $t_i$};   % Element/Constant
            \node[draw,circle,right = of a] (nn) {\textbf{:Element}\\\textbf{:Null}\\\textit{value}: $t_j$};      % Element/Null
            \path
            (a) edge [] node[below, near start] {$0..*$} node[below, near end] {$1..*$} node[above] {\textbf{:P} \{\textit{rank}: $i$\}} (nc)
            (a) edge [] node[below, near start] {$0..*$} node[below, near end] {$1..*$} node[above] {\textbf{:P} \{\textit{rank}: $j$\}} (nn)
            ;
        \end{tikzpicture}
    \end{adjustbox}
\end{frame}

\begin{frame}{Exemple}
    \centering
    \begin{multline*}
        \mathcal{D} = \{ Pat(Mia), PrescExam(Mia, N_1), SOSY(Mia, pain),\\
        Diag(Mia, N_3, N_2), ResultExam(Mia, \textit{x-ray}, N_3) \}
    \end{multline*}
    \vfill
    \begin{adjustbox}{width=.8\linewidth}
        \begin{tikzpicture}[shorten >=3pt,->,node distance=4cm,on grid,every text node part/.style={align=center}]
            \node[draw,circle] (Mia) {$n_1$\\Mia};
            \node[draw,left = of Mia] (pat) {$n_{11}$\\Pat};
            \node[draw,circle,above = 2cm of pat] (n1) {$n_2$\\$N_1$};
            \node[draw,circle,below = 2cm of pat] (temp) {$n_3$\\x-ray};
            \node[draw,right = of n1] (presc) {$n_4$\\PrescExam};
            \node[draw,right = of presc] (sosy) {$n_5$\\SOSY};
            \node[draw,right = of temp] (res) {$n_6$\\ResultExam};
            \node[draw,circle,right = of res] (n4) {$n_7$\\$N_3$};
            \node[draw,circle,right = of sosy] (fever) {$n_8$\\pain};
            \node[draw,right = of Mia] (diag) {$n_9$\\Diag};
            \node[draw,circle,right = of diag] (n2) {$n_{10}$\\$N_2$};
            \path
            (pat) edge [] node[above] {$r_1$} node[below] {rank: 0} (Mia)
            (presc) edge [] node[right] {$r_2$} node[left] {rank: 0} (Mia)
            edge [] node[above] {$r_3$} node[below] {rank: 1} (n1)
            (sosy) edge [] node[left] {$r_4$} node[right] {rank: 0} (Mia)
            edge [] node[above] {$r_5$} node[below] {rank: 1} (fever)
            (diag) edge [] node[above] {$r_6$} node[below] {rank: 0} (Mia)
            edge [] node[right] {$r_7$} node[left] {rank: 1} (n4)
            edge [] node[above] {$r_8$} node[below] {rank: 2} (n2)
            (res) edge [] node[right] {$r_9$} node[left] {rank: 0} (Mia)
            edge [] node[above] {$r_{10}$} node[below] {rank: 1} (temp)
            edge [] node[above] {$r_{11}$} node[below] {rank: 2} (n4)
            ;
        \end{tikzpicture}
    \end{adjustbox}
\end{frame}

\begin{frame}{LinkedNulls}
    \begin{multline*}
        \mathcal{D} = \{ Pat(Mia), PrescExam(Mia, N_1), SOSY(Mia, pain),\\
        {\only<2->{\color{red}}Diag(Mia, N_3, N_2)},
        {\only<3>{\color{red}}ResultExam(Mia, \textit{x-ray}, N_3)}
        \}
    \end{multline*}
    \vfill
    \centering
    \begin{adjustbox}{width=.8\linewidth}
        \begin{tikzpicture}[shorten >=3pt,->,node distance=4cm,on grid,every text node part/.style={align=center}]
            \node[draw,circle] (Mia) {$n_1$\\Mia};
            \node[draw,left = of Mia] (pat) {$n_{11}$\\Pat};
            \node[draw,circle,above = 2cm of pat] (n1) {$n_2$\\$N_1$};
            \node[draw,circle,below = 2cm of pat] (temp) {$n_3$\\x-ray};
            \node[draw,right = of n1] (presc) {$n_4$\\PrescExam};
            \node[draw,right = of presc] (sosy) {$n_5$\\SOSY};
            \node[draw,circle,right = of sosy] (fever) {$n_8$\\pain};

            \only<1-2>{\node[draw,right = of temp] (res) {$n_6$\\ResultExam};}
            \only<3>{\node[draw,right = of temp,red] (res) {$n_6$\\ResultExam};}

            \only<1>{\node[draw,circle,right = of res] (n4) {$n_7$\\$N_3$};}
            \only<2-3>{\node[draw,circle,right = of res,red] (n4) {$n_7$\\$N_3$};}

            \only<1>{\node[draw,right = of Mia] (diag) {$n_9$\\Diag};}
            \only<2-3>{\node[draw,right = of Mia,red] (diag) {$n_9$\\Diag};}

            \node[draw,circle,right = of diag,red] (n2) {$n_{10}$\\$N_2$};

            \path (pat) edge [] node[above] {$r_1$} node[below] {rank: 0} (Mia);
            \path (presc) edge [] node[right] {$r_2$} node[left] {rank: 0} (Mia);
            \path (presc) edge [] node[above] {$r_3$} node[below] {rank: 1} (n1);
            \path (sosy) edge [] node[left] {$r_4$} node[right] {rank: 0} (Mia);
            \path (sosy) edge [] node[above] {$r_5$} node[below] {rank: 1} (fever);
            \path (diag) edge [] node[above] {$r_6$} node[below] {rank: 0} (Mia);
            \path (res) edge [] node[right] {$r_9$} node[left] {rank: 0} (Mia);
            \path (res) edge [] node[above] {$r_{10}$} node[below] {rank: 1} (temp);

            \only<1>{\path (diag) edge [] node[right] {$r_7$} node[left] {rank: 1} (n4);}
            \only<2-3>{\path (diag) edge [red] node[right] {$r_7$} node[left] {rank: 1} (n4);}

            \only<1>{\path (diag) edge [] node[above] {$r_8$} node[below] {rank: 2} (n2);}
            \only<2-3>{\path (diag) edge [red] node[above] {$r_8$} node[below] {rank: 2} (n2);}

            \only<1-2>{\path (res) edge [] node[above] {$r_{11}$} node[below] {rank: 2} (n4);}
            \only<3>{\path (res) edge [red] node[above] {$r_{11}$} node[below] {rank: 2} (n4);}
            ;
        \end{tikzpicture}
    \end{adjustbox}
\end{frame}

\begin{frame}{Évaluation : Temps d'exécution par \acrshort{sgbd}}
    \centering
    \begin{tikzpicture}
        \begin{axis}[xbar, every axis plot/.append style={fill}, axis x line=none, axis line style={draw=none}, tick style={draw=none}, symbolic y coords = {MySQL,Neo4J}, enlarge y limits = 0.5, restrict x to domain=0:*, nodes near coords, ytick=data, xlabel={Temps}, x unit=\si{\ms}, legend columns=-1, legend style={draw=none, at={(0.5,0)}, anchor=north}, width=.9\linewidth, height=.9\textheight]
            \addplot+[area legend] table [y=db, x=chase, col sep=comma] {time_per_db.csv};
            \addlegendentry{Chase};

            \addplot+[area legend] table [y=db, x=nullBucket, col sep=comma] {time_per_db.csv};
            \addlegendentry{Null bucket};

            \addplot+[area legend] table [y=db, x=partitions, col sep=comma, col sep=comma] {time_per_db.csv};
            \addlegendentry{LinkedNulls};

            \addplot+[area legend] table [y=db, x=simplifications, col sep=comma] {time_per_db.csv};
            \addlegendentry{Simplifications};
        \end{axis}
    \end{tikzpicture}
\end{frame}

%\section{Conclusion}

\begin{frame}{Résultats}
    \begin{itemize}
        \item L'incrémentalité se fait de deux manières :
              \begin{itemize}
                  \item Ne considérer que l'instanciation des règles à partir de la mise à jour
                  \item Ne vérifier que les simplifications sur les valeurs nulles \emph{impactées}
              \end{itemize}
        \item L'incrémentalité améliore les performances et permet d'utiliser des bases de données
        \item Les bases de données graphiques et les requêtes de chemin aident à la récupération de l'ensemble des LinkedNulls
        \item La modélisation graphe rend couteuse la recherche d'homomorphismes\vfill\vline\vfill
        \item Modélisations mixtes relationnelles et basées sur les graphes \cite{hassanGRFusionGraphsFirstClass2018}
        \item Adapter notre travail à des modélisations LPG plus standard
    \end{itemize}
\end{frame}
