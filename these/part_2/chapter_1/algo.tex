\SetKw{skip}{SKIP}

% \SetKwData{epochs}{epochs}
\SetKwData{simp}{simp}
% \SetKwData{minSupport}{minSupport}
\SetKwData{groupFound}{groupFound}
\SetKwData{relationshipFound}{relationshipFound}
\SetKwData{collectionFound}{collectionFound}
% \SetKwData{splitColl}{splitColl}
\SetKwData{subSet}{subSet}
\SetKwData{subPos}{subPos}
\SetKwData{st}{st}

\SetKwFunction{combination}{combination}
\SetKwFunction{findSTwithMinLeavesTree}{findSTwithMinLeavesTree}
\SetKwFunction{reduce}{reduce}
\SetKwFunction{insElem}{ins\_elem}
\SetKwFunction{delElem}{del\_elem}
\SetKwFunction{leaves}{leaves}
% \SetKwFunction{depth}{depth}

Dans cette section, nous décrivons en détail une implémentation de la procédure de réécriture des arbres.
Notre approche ici, est d'unifier les arbres en éliminant les variations de structurelle (c.-à-d. de minimiser le nombre de règles de production) et en maximisant la fréquence d'apparition de ces structures.
L'idée est la suivante : à chaque étape, on essaye d'effectuer l'opération la moins destructive, si l'arbre est modifié, on recommence le cycle pour vérifier la validité du schéma et recalculer les classes d'équivalences qui ont pu changer.
Si aucun changement n'a pu être réalisé, on essaye une autre opération plus destructive que la précédente.
La procédure principale~\ref{algo:struct:rewrite} se charge d'orchestrer les différentes opérations d'édition et implémente la boucle décrite dans la section précédente.
On suppose qu'on a en entrée un unique arbre en tant que forêt enracinée d'arbre d'instances.
La phase de prétraitement qui consiste à enrichir et à simplifier les arbres de syntaxe a déjà été réalisée.
On définit quatre paramètres supplémentaires :
\begin{itemize}
    \item la fonction de similarité $f$ ;
    \item le seuil $\tau$ de similarité ;
    \item le support minimum qui détermine quand un élément doit être considéré fréquent ;
    \item l'epoch qui borne le nombre de cycles que l'on autorise.
\end{itemize}
L'algorithme proposé est une version simplifiée de la boucle proposée précédemment.
Il converge vers une solution qui est valide par rapport à la méta-grammaire $\mathbb{G}$.
L'epoch permet de garantir sa terminaison même si cela implique que des parties de l'arbre ne sont pas valide à la fin de l'exécution.
L'algorithme s'affranchit de l'extraction de la grammaire et sa vérification à chaque étape.
Cela est rendu possible, car les opérations de transformations s'appliquent uniquement sur les parties invalides de l'arbre.
C'est-à-dire que quand plus aucune transformation n'est possible, la grammaire est valide.

\begin{procedure}[htb]
    \caption{rewrite($T$ = ($D$, $l$), epochs, $\tau$, minSupport)}
    \label{algo:struct:rewrite}

    $\simp \gets \textsc{True}$\;
    $i \gets 0$\;
    \While{$i \leq \text{epochs}$ and $\simp = \textsc{True}$}{
        $i \gets i + 1$\;

        \tcp{Supprimer les nœuds redondants}
        \lForAll{$p \in D$  tel que $l(p) \notin \{`ENT`, `LEAF`\}$\label{algo:struct:rewrite:reduce}}{
            \reduce{$T$, $p$, $\emptyset$}
        }

        \tcp{Identifier les nœuds groupes}
        \ref{algo:struct:rewrite-findGroups}$(T, \tau, \text{minSupport})$\;

        \tcp{Ajouter des nœuds pour séparer un sous-groupe fréquent}
        $\simp \gets \ref{algo:struct:rewrite-findSubgroups}(T, \tau, \text{minSupport})$\;

        \tcp{Fusionner des nœuds voisins pour augmenter un groupe}
        \lIf{$\simp = \textsc{False}$}{
            $\simp \gets \ref{algo:struct:rewrite-mergeGroups}(T, \tau, \text{minSupport})$
        }

        \tcp{Identifier les collections de groupes}
        \lIf{$\simp = \textsc{False}$}{
            $\simp \gets \ref{algo:struct:rewrite-findCollections}(T, \tau, \text{minSupport})$
        }

        \tcp{Identifier les relations}
        \lIf{$\simp = \textsc{False}$}{
            $\simp \gets \ref{algo:struct:rewrite-findRelationship}(T, \tau, \text{minSupport})$
        }

        \tcp{Identifier les collections de relations}
        \lIf{$\simp = \textsc{False}$}{
            $\simp \gets \ref{algo:struct:rewrite-findCollections}(T, \tau, \text{minSupport})$
        }

        \tcp{Aplatir l'arbre en haut}
        \If{$\simp = \textsc{False}$}{
            \ForEach{$p \in D$ tel que $depth(p) = 1$\label{algo:struct:rewrite:reduce-top}}{
                $\simp \gets \reduce{T, p, \{`ENT`, `GROUP`, `REL`, `COLL`\}}$\;
            }
        }

        \tcp{Supprimer les nœuds non étiquetés en bas}
        \If{$\simp = \textsc{False}$}{
            \ForEach{$u.j \in$ où $l(u.j) = `ENT$'\label{algo:struct:rewrite:reduce-bot}}{
                $\simp \gets \reduce{T, u, \{`ENT`, `GROUP`, `REL`, `COLL`\}}$\;
            }
        }
    }
\end{procedure}

Dans la procédure, la variable \textsf{simp} permet d'enregistrer si une simplification a été faite.
Si c'est le cas, la boucle continue à l'itération suivante tant que l'epoch n'est pas dépassé.
Pour une itération $i$, on récupère cette information à chaque étape et on continue vers les opérations suivantes uniquement si aucune modification n'est opérée par rapport à l'arbre de l'itération $i - 1$.
Il est à noter que l'on n'utilise pas l'opération \ref{algo:struct:rewrite-findGroups} pour savoir si une simplification a été effectuée, car cette opération identifie les groupes à chaque étape et ne constitue donc pas une étape de reconstruction.

L'algorithme commence (à la ligne~\ref{algo:struct:rewrite:reduce}) par simplifier l'arbre en supprimant les nœuds redondants.
Dans la suite, on identifie les nœuds, candidats pour représenter des groupes.
Une fois ces premières étapes effectuées, la procédure tente successivement d'effectuer des transformations en commençant par la moins destructrice.
Dans l'ordre, on retrouve :
\begin{enumerate}
    \item \ref{algo:struct:rewrite-findSubgroups} pour construire des sous-groupes fréquents ;
    \item \ref{algo:struct:rewrite-mergeGroups} pour construire des groupes plus grands en incorporant d'autres informations, mais qui maintient sa similarité avec sa classe d'équivalence ainsi qu'une fréquence au-dessus de support minimum ;
    \item \ref{algo:struct:rewrite-findCollections} pour construire des collections de groupes (ces collections peuvent être utilisées lors de l'étape suivante) ;
    \item \ref{algo:struct:rewrite-findRelationship} pour construire des relations entre deux groupes ;
    \item \ref{algo:struct:rewrite-findCollections} pour construire des collections de relations.
\end{enumerate}

Une fois ces cinq opérations effectuées, si aucune modification n'a pu être effectuée, on cherche à supprimer des structures trop complexes qui ne sont pas catégorisable.
Notamment, les arbres peuvent avoir une grande profondeur, mais nos grammaires de schéma autorisent uniquement une profondeur maximale de 5.
L'idée est donc de mettre à plat des structures trop profondes en supprimant un à un les niveaux supérieurs.
L'algorithme construit les instances en commençant par le bas de l'arbre et en remontant, les niveaux supérieurs sont donc les plus susceptibles de ne pas être catégorisés.
La ligne~\ref{algo:struct:rewrite:reduce-top} supprime alors l'ensemble des racines qui n'ont pas été catégorisée en tant qu'\emph{entité}, \emph{groupe}, \emph{relation} ou \emph{collection}.
S'il n'est plus possible de détruire les racines, on détruit l'arbre par le bas en supprimant les niveaux intermédiaires situés au-dessus des entités (ligne~\ref{algo:struct:rewrite:reduce-bot}).

Dans la suite, on étudie en détail l'implémentation des opérations de transformations mise en place.

\subsection{Opérations de structuration}

\begin{procedure}
    \caption{findGroups($T$ = ($D$, $l$), $\tau$, minSupport)}
    \label{algo:struct:rewrite-findGroups}

    \tcp{Identifier les clusters de sous-arbres équivalents et garder uniquement les fréquents}
    $equivalent\_st \gets \{equiv\_pos \mid equiv\_pos \in D/\equiv_\tau, |equiv\_pos| \ge$ minSupport$\}$\;
    $k \gets 0$\;

    \While{$equivalent\_st \neq \emptyset$}{
        $ST\_min \gets \findSTwithMinLeavesTree(equivalent\_st)$\;
        $equivalent\_st \gets equivalent\_st \setminus ST\_min$\;

        \ForEach{$st \in ST\_min$ tel que $\{e \mid e \in st, l(e) \neq `GROUP`\} = \emptyset$}{
            $j \gets 0$\;
            Construire $T_{GROUP} = (D_{GROUP}, t_{GROUP})$ un nouvel arbre avec $t_{GROUP}(\epsilon) = `GROUP_k`$\;

            \ForEach{$l \in \leaves(st)$}{
                $\insElem(T_{GROUP}, l, j)$\;
                $j \gets j + 1$\;
            }

            Soit $u$ tel que $T|_u = st$\;
            $\insElem(T, t_{GROUP}, u + 1)$\;
            $\delElem(T, u)$\;
            $k \gets k+1$\;
        }
    }
\end{procedure}

% \nh{Something is not great here, in findSubgroups. We mixed a set of positions with a set of labels. The set contains trees but the combinaition should not allow a label to appear multiple times}

\begin{procedure}
    \caption{findSubgroups($T$ = ($D$, $l$), minSupport)}
    \label{algo:struct:rewrite-findSubgroups}

    $\groupFound \gets \textsc{False}$\;

    \ForAll{sous-arbre \st tel que $\st = T|_u$ et $l(u) \notin \{`ENT`, `REL`, `COLL`\}$}{
        $S_{ENT} \gets \{T|_{u.i} \mid \forall i \ l(u.i) = `ENT`\}$ \tcp*{Ensemble des arbres d'entités enfants de \st}
        $group\_support \gets |[\st]_\tau|$\;

        $k \gets |S_{ENT}|$\;
        \While{$k > 1$}{
            $j \gets 0$\;

            \tcp{Pour chaque sous-ensemble de taille $k$ dans $\mathcal{P}_{S_{ENT}}$}
            \ForEach{combinaison  $combi_j \in \combination(S_{ENT}, k)$}{
                $T_j \gets \text{copy}(T)$ \tcp*{$T_j$ est l'arbre où l'on remplace l'ensemble $combi_j$ par un groupe}
                
                $\insElem(T_j, GROUP, u.0)$\;
                \ForAll{$\st_E \in combi_j$}{
                    $\delElem(T_j, u.i)$ tel que $T_j|_{u.i} = \st_E$\;
                    $\insElem(T_j, \st_E, u.0.0)$\;
                }

                $support_j \gets |[T_j|_{u.0}]|$ \tcp*{$[T_j|_{u.0}]$ est l'ensemble équivalent qui contient le sous-arbre $T_j|_{u.0}$}
                $j \gets j + 1$\;
            }

            \BlankLine
            \tcp{Choisir le groupe qui a le plus grand support}
            $j_{max}$ est un indice tel que $support_{j_{max}} = \max(support_j)$\;

            \uIf{$support_{j_{max}} \ge min\_support$ et $support_{j_{max}} > group\_support$}{
                \tcp{On continue de combiner les arbres d'entités restants dans \st}
                $\groupFound \gets \textsc{True}$\;
                $S_{ENT} \gets S_{ENT} \setminus combi_{j_{max}}$\;
                $k \gets \min(|S_{ENT}|, k)$ \tcp*{La taille de la combinaison suivante $k$ est réduite lorsque $|S_{ENT}| < k$}
                $T \gets T_{j_{max}}$ \tcp*{L'arbre modifié est sauvegardé}
            } \Else {
                $k \gets k - 1$\;
            }
        }
    }

    \Return \groupFound \;
\end{procedure}

\begin{procedure}
    \caption{mergeGroups($T$ = ($D$, $l$), minSupport)}
    \label{algo:struct:rewrite-mergeGroups}

    $\groupFound \gets \textsc{False}$\;

    \ForAll{sous-arbre \st tel que $\st = T|_u$ and $l(u) \notin \{`ENT`, `GROUP`, `REL`, `COLL`\}$}{
        $S_{GROUP} = \{T|_{u.i} \mid \forall i ~ l(u.i) = `GROUP`\}$ \tcp*{Ensemble des arbres groupe enfants de \st}
        $S_{ENT} = \{T|_{u.i} \mid \forall i ~ l(u.i) = `ENT`\}$ \tcp*{Ensemble des arbres d'entités enfants de \st}

        $k \gets |S_{GROUP}/\equiv_\tau| + |S_{ENT}|$\;
        \While{$k > 1$}{
            $j \gets 0$\;

            \tcp{Pour chaque sous-ensemble de taille $k$ dans $\mathcal{P}_{S_{GROUP} \cup S_{ENT}}$}
            \ForAll{combinaison $combi_j \in \combination(S_{GROUP} \cup S_{ENT}, k)$}{
                %\tcp{Pour chaque sous-ensemble de taille $k$ dans $\mathcal{P}_{S}$}
                $ST = \{x \mid \forall x~l(x) = `GROUP`\}$\;
                $ST_{ENT} = \{T|_{u.i} \mid \forall x~l(x) = `ENT`\} \cup \{x \mid \forall g \in ST, \forall x \in g\}$\;

                \lIf{$ST_{ENT}$ contient plusieurs fois la même entité}{\skip}

                $subgroup\_support_j \gets \max(|g| \mid \forall g \in ST)$\;
                $T_j \gets \text{copy}(T)$ \tcp*{$T_j$ est l'arbre où l'on remplace l'ensemble $combi_j$ par un groupe}

                $\insElem(T_j, GROUP, u.0)$\;
                \ForAll{$\st_E \in ST_{ENT}$}{
                    $\delElem(T_j, u.i)$ tel que $T_j|_{u.i} = \st_E$\;
                    $\insElem(T_j, \st_E, u.0.0)$\;
                }

                $support_j \gets |[T_j|_{u.0}]_\tau|$ \tcp*{$[T_j|_{u.0}]$ est l'ensemble équivalent qui contient le sous-arbre $T_j|_{u.0}$}
                $j \gets j + 1$\;
            }

            \BlankLine
            \tcp{Choisir le groupe qui a le plus grand support}
            $j_{max}$ est un indice tel que $support_{j_{max}} = \max\{support_j \mid support_j \ge subgroup\_support_j\}$\;

            \uIf{$support_{j_{max}} \ge min\_support$}{
                \tcp{On continue de combiner les arbres d'entités restants dans \st}
                $\groupFound \gets \textsc{True}$\;
                $S_{ENT} \gets S_{ENT} \setminus combi_{j_{max}}$\;
                \tcp{La taille de la combinaison suivante $k$ est réduite lorsque $|S_{ENT}| < k$}
                $k \gets \min(|S_{ENT}|, k)$\;
                $T \gets T_{j_{max}}$ \tcp*{L'arbre modifié est sauvegardé}
            } \Else {
                $k \gets k - 1$\;
            }
        }
    }

    \Return \groupFound \;
\end{procedure}

\begin{procedure}
    \caption{findRelationship($T$ = ($D$, $l$), minSupport)}
    \label{algo:struct:rewrite-findRelationship}

    $\relationshipFound \gets \textsc{False}$\;

    \ForEach{sous-arbre \st tel que $\st = T|_u$, $|\st| = 2$, et $l(u) \notin \{`ENT`, `GROUP`, `REL`, `COLL`\}$}{

        \uIf{$l(u.0) = `GROUP`$ et $l(u.1) = `GROUP`$}{
            \tcp{tous les enfants de \st sont des nœuds groupe, il est donc marqué comme relation}
            $l(u) \gets `REL`$\;
            $\relationshipFound \gets \textsc{True}$\;
        }

        \ElseIf{$(l(u.0) = `COLL`$ et $l(u.1) = `GROUP`)$ ou $(l(u.0) = `GROUP`$ et $l(u.1) = `COLL`)$}{
            $group \gets u.l$ tel que $l(u.l) = `GROUP`$\;
            $coll \gets u.m$ tel que $l(u.m) = `COLL`$\;

            \ForAll{$i \in coll$}{
                $pos \gets |T|_{coll}|$\;
                \tcp{Ajout d'une relation pour chaque paire $\langle group, T|_{coll.i} \rangle$}
                $\insElem(T, `REL`, u.pos)$\;
                $\insElem(T, T|_{group}, u.pos.0)$\;
                $\insElem(T, T|_{coll.i}, u.pos.1)$\;
                $\delElem(T, coll.i)$\;
            }
            
            $\delElem(T, group)$\;
            $\relationshipFound \gets \textsc{True}$\;
        }
    }

    \Return \relationshipFound \;
\end{procedure}

\begin{procedure}
    \caption{findCollections($T$ = ($D$, $l$), minSupport)}
    \label{algo:struct:rewrite-findCollections}

    $\collectionFound \gets \textsc{False}$\;

    \ForEach{sous-arbre \st tel que $\st = T|_u$ et $l(u) \notin \{`ENT`, `GROUP`, `REL`, `COLL`\}$}{
        $pos \gets |st|$\;

        \tcp{Construction d'une collection de groupes ou de relations}
        \ForEach{sous-ensemble \subSet tel que $\exists x \forall u.i \in \subSet$ où $t|_{u.i} \in [x]$, $l(u.i) \in \{`GROUP`, `REL`\}$ et $|\subSet| \ge 2$}{
            $\collectionFound \gets \textsc{True}$\;
            $\insElem(T, `COLL`, u.pos)$\;
            \ForAll{$u.i \in \subSet$}{
                $\insElem(T, T|_{u.i}, u.pos.0)$\;
                $\delElem(T, \subPos)$\;
            }
        }

        \tcp{Fusion de collections}
        \ForEach{sous-ensemble \subSet tel que $\exists x \forall u.i \in \subSet$ où $T|_{u.i} \in [x]$, $l(u.i) \in \{`COLL`\}$ et $|\subSet| \ge 2$}{
            $\collectionFound \gets \textsc{True}$\;
            $\insElem(T, `COLL`, u.pos)$\;

            \ForAll{$u.i.j$ tel que $u.i \in \subSet$}{
                $\insElem(T, T|_{u.i.j}, u.pos.0)$\;
                $\delElem(T, u.i.j)$\;
            }
        }

        \tcp{Ajout d'éléments à une collection}
        \ForAll{$group, coll$ tel que $\exists x, i, j$ où $l(u.i) = `GROUP`$, $l(u.j) = `COLL`$, $T|_{u.i} \in [x]$ et $\forall k T|_{u.j,k} \in [x]$}{
            $\collectionFound \gets \textsc{True}$\;
            $group\_pos = |T|_{u.j}|$\;
            $\insElem(T, T|_{u.i}, u.j.group\_pos)$\;
            $\delElem(T, u.i)$\;
        }
    }

    \Return \collectionFound \;
\end{procedure}

\FloatBarrier
