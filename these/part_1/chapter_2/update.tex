Cette section vise à détailler l'ensemble des opérations incrémentales nécessaires pour maintenir la cohérence d'une base de données lors de mises à jour.
Considérons $\mathcal{D}$ comme une instance de base de données cohérente, mais incomplète, et $U$ comme un ensemble de mises à jour.
La notation $\mathcal{D} \diamondsuit U$ représente l'insertion ou la suppression des mises à jour dans ou à partir de $\mathcal{D}$.
Dans \cite{chabinConsistentUpdatingDatabases2020}, une approche "from-scratch" génère une nouvelle instance de base de données notée $\mathcal{D}' = core(upd(\mathcal{D} \diamondsuit U))$, où $upd$ est le processus de mise à jour détaillé dans cet ouvrage.
En revanche, l'approche ici présentée est une version \textit{incrémentale} du processus de mise à jour, désignée par $upd_{|U}$.
Ainsi, la nouvelle instance de base de données est définie comme $\mathcal{D}' = core_{|NullBucket}(upd_{|U}(\mathcal{D}\diamondsuit U))$, où $NullBucket$ est l'ensemble des valeurs nulles impactées par la mise à jour ($upd_{|U}$) appliquée à $\mathcal{D} \diamondsuit U$.

\subsection{Insertion}
\label{sec:update:insert}
L'algorithme~\ref{algo:update:insert} décrit la procédure pour l'insertion d'un ensemble d'atomes instanciés $I$ dans l'instance de la base de données $\mathcal{D}$ selon l'ensemble de contraintes $\mathbb{C}$.
Cette procédure commence par calculer les effets de bords résultant de l'insertion de l'ensemble $I$ d'atomes instanciés dans $\mathcal{D}$, en utilisant le mécanisme du \gls{chase} (ligne~\ref{algo:update:insert:chase}).
Le \gls{core} de l'ensemble $\mathcal{D} \cup ToIns$ est ensuite calculé (ligne~\ref{algo:update:insert:core}) en prenant en compte uniquement :
\begin{enumerate*}[label=(\alph*)]
    \item les valeurs nulles stockées dans \textsc{NullBucket} (récupérées via $Q_{bucket}$, ligne~\ref{algo:update:insert:bucket}) et
    \item les valeurs nulles associées
\end{enumerate*}
$Q_{bucket}(I){[S]}$ recherche les valeurs nulles présentes dans les atomes moins spécifiques qu'un atome de l'ensemble $S$.
Lors d'une insertion, les degrés de nullité (ou profondeur dans l'arbre de génération des \glspl{tgd}) sont initialisés à 0.
Lorsqu'une contrainte est appliquée, les valeurs nulles générées se voient attribuer un degré $\delta + 1$ (où $\delta$ correspond au degré maximal des valeurs nulles dans le corps de la contrainte) ou 0 s'il n'y a pas de valeurs nulles dans le corps.
Si $\delta(N) \geq \delta{\max}$, l'insertion est refusée et $\mathcal{D}$ reste inchangée.
Dans l'algorithme~\ref{algo:update:insert}, une vérification est effectuée pour s'assurer que toutes les valeurs nulles dans l'instance simplifiée ont un degré inférieur à $\delta_{\max}$ (vérification via $Q_{degree}$, ligne~\ref{algo:update:insert:testNull}).
Si cette condition est satisfaite, les degrés des valeurs nulles sont remis à 0 (via $Q_{\delta}$, ligne~\ref{algo:update:insert:setDegree}), et $\mathcal{D}'$ est retournée comme instance modifiée.

\begin{algorithm}[ht]
    \caption{$\textsc{Insert}(\mathcal{D}, \mathbb{C}, \delta_{max}, I)$}
    \label{algo:update:insert}
    $ToIns := \textsc{Chase4Insert}(\mathcal{D}, \mathbb{C}, \delta_{max}, I)$ \label{algo:update:insert:chase} \;
    $NullBucket := \{N_j \mid N_j \text{ est une valeur nulle obtenue par } Q_{bucket}(\mathcal{D} \cup ToIns)\}$ \label{algo:update:insert:bucket} \;
    $\mathcal{D}' := \textsc{Simplify}(\mathcal{D} \cup ToIns, NullBucket)$ \label{algo:update:insert:core} \;
    \uIf{$Q_{degree}(\mathcal{D}')_{[NullBucket,\delta_{max}]}$ \label{algo:update:insert:testNull}}{
        $Q_{\delta}(\mathcal{D}')_{[NullBucket,0]}$ \label{algo:update:insert:setDegree} \;
        \Return $\mathcal{D}'$ \;
    }
    \Else{
        \Return $\mathcal{D}$ \;
    }
\end{algorithm}

\begin{example}

\end{example}

\subsection{Suppression}
\label{sec:update:delete}
L'algorithme~\ref{algo:update:delete} détaille la méthode incrémentale pour effectuer la suppression d'un ensemble d'atomes instanciés $I$ dans une instance de base de donnée $\mathcal{D}$.
À la ligne~\ref{del:iso}, la requête $Q_{Iso}$ récupère tous les atomes de $\mathcal{D}$ isomorphes à un atome de l'ensemble $I$.
Par exemple, si $I = {P(a, N_1)}$ et $\mathcal{D}1= {P(a, N_5)}$, la requête $Q{Iso}$ renverrait ${P(a, N_5)}$.
À la ligne~\ref{del:chase}, la fonction \textsc{Chase4Delete} est utilisée pour calculer de manière incrémentale les effets secondaires.
Cette fonction génère deux ensembles d'atomes, $ToDel$ et $ToIns$, représentant respectivement les atomes à supprimer et à insérer comme effets secondaires.
Une fois que ces effets secondaires ont été appliqués à $\mathcal{D}$ pour obtenir $\mathcal{D}'$ (ligne~\ref{del:buildInstance}), la nouvelle instance est simplifiée de manière similaire à l'insertion, en calculant le \gls{core}.
Les nullités impactées sont générées à la ligne~\ref{del:bucket}, et l'instance simplifiée est calculée à la ligne~\ref{del:core}.
Contrairement aux insertions, les suppressions ne sont jamais rejetées : la procédure est garantie de se terminer, produisant au pire des cas une instance vide.
Ceci est assuré par la procédure de \textsc{Chase4Delete}, qui marquera les nouveaux atomes générés dépassant le dégréé de nullité maximum $\delta_{max}$ comme étant à supprimer, garantissant ainsi la terminaison de la procédure.

\begin{algorithm}[ht]
    \caption{$\textsc{Delete}(\mathcal{D}, \mathbb{C}, \delta_{max}, I)$}
    \label{algo:update:delete}
    $del_{iso} := Q_{iso}^{[I]}(\mathcal{D})$ \;
    $ToDel, ToIns := \textsc{Chase4Delete} (\mathcal{D}, \mathbb{C}, \delta_{max}, del_{iso})$\;
    $\mathcal{D}' := (\mathcal{D} \cup ToIns) \setminus ToDel$ \;
    $NullBucket := \{N_j \mid N_j \text{ est une valeur nulle obtenue par } q_{bucket}(\mathcal{D}')_{[ToIns \cup ToDel]}\}$ \;
    $\mathcal{D}' := \textsc{Simplify}(\mathcal{D}', NullBucket)$ \;
    \Return $\mathcal{D}'$
\end{algorithm}

\begin{example}

\end{example}
