\cite{chabinUsingGraphGrammar2019} définit un cadre théorique et appliqué pour assurer la cohérence d'un graphe de connaissances \gls{rdf} basé sur la réécriture de graphe.
Il propose \gls{setup} qui s'appuie sur la réécriture de graphes pour la maintenance des graphes \gls{rdf}.
Étant donné une base \gls{rdf} modélisée avec le schéma \gls{rdfs}, l'objectif est de maintenir le respect des contraintes d'intégrité de \gls{rdfs} tel qu'expliqué dans \cite{flourisFormalFoundationsRDF2013}, \cite{halfeld-ferrariRDFUpdatesConstraints2017} ou encore \cite{chabinConsistentUpdatingDatabases2020} après mise à jour de l'instance.
Les règles de la sémantique \gls{rdfs} sont exprimées sous forme de règles logique en utilisant les symboles de prédicats définis dans la table~\ref{table:update:soa:rdfs}.
Si l'on prend la règle $(\forall x,y) CI(x,y) \to Cl(y)$, elle signifie que pour que tout $x$ soit instance de $y$ il faut que $y$ soit une classe.
\cite{chabinUsingGraphGrammar2019} propose de modéliser les règles de la sémantique \gls{rdf} en utilisant la réécriture de graphes comme montré sur la figure~\ref{fig:gram_rule}.
Les règles ne peuvent s'appliquer que si leur application maintient la cohérence.

\begin{figure}[ht]
    \centering
    \begin{subfigure}[b]{.3\textwidth}
        \centering
        \begin{tikzpicture}[->,auto,node distance=2.5cm,thick,main node/.style={draw}]
            \node[main node] (1) {Class: $A$};
            \node[main node] (2) [below of=1] {Prop: $A$};
            \node[main node] (3) [right of=1] {Ind: $A$};
            \node[main node] (4) [right of=2] {Class: $B$};
            \path[every node/.style={font=\sffamily\small}]
            (3) edge node {CI} (4);
        \end{tikzpicture}
        \caption{NAC}
        \label{fig:gram_rule:nac}
    \end{subfigure}
    \begin{subfigure}[b]{.3\textwidth}
        \centering
        \begin{tikzpicture}[->,auto,node distance=2.5cm,thick,main node/.style={draw}]
            \node[main node] (2) {Class: $B$};
        \end{tikzpicture}
        \caption{LHS}
        \label{fig:gram_rule:lhs}
    \end{subfigure}
    \begin{subfigure}[b]{.3\textwidth}
        \centering
        \begin{tikzpicture}[->,auto,node distance=2.5cm,thick,main node/.style={draw}]
            \node[main node] (1) {Class: $B$};
            \node[main node] (2) [below of=1] {Ind: $A$};
            \path[every node/.style={font=\sffamily\small}]
            (2) edge node {CI} (1);
        \end{tikzpicture}
        \caption{RHS}
        \label{fig:gram_rule:rhs}
    \end{subfigure}
    \caption{Règle de réécriture simplifiée pour le fait $CI(A,B)$}
    \label{fig:gram_rule}
\end{figure}

Une grammaire est un ensemble de règles définissant un langage.
Ces règles de réécritures sont des fonctions qui, pour une entrée donnée donne une nouvelle sortie.
Les grammaires permettent de définir l'ensemble des "mots" valide pour un langage donné.
Les grammaires de graphes sont des grammaires appliquées aux graphes.
Les règles de réécriture de graphes sont de la forme $\text{LHS} \to \text{RHS}$ où \gls{lhs} est un motif et \gls{rhs} le résultat de l'application de la règle.
Il existe un morphisme entre \gls{lhs} et \gls{rhs} définissant comment la règle doit être appliquée (dans l'exemple précédent, un morphisme existe sur la classe $B$).
Une règle est applicable s'il existe un isomorphisme entre \gls{lhs} et le graphe $G$ que l'on construit.
Il est possible d'ajouter des \gls{nac}, comme \gls{lhs} elles permettent de définir un motif qui, s'il trouve un isomorphisme dans $G$, rend la règle inapplicable (Dans l'exemple, les \gls{nac}s sont utilisées pour éviter l'insertion du fait s'il est déjà présent dans la base ou si le type de $A$ n'est pas le bon).

\begin{example}
    En considérant une base de connaissance cohérente représentée par le graphe $G$ figure~\ref{fig:rule_ci}.
    Si l'on veut appliquer la règle de réécriture figure~\ref{fig:gram_rule} on remarque que la règle ne peut pas s'appliquer, car la \gls{nac} est vérifiée ($A$ est une classe).
    Il faut donc appliquer un effet de bords pour supprimer ce fait (en rouge).
    La règle devient alors applicable (en bleu).
\end{example}

\begin{figure}
    \centering
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \begin{tikzpicture}[->,auto,node distance=2.5cm,thick,main node/.style={draw}]
            \node[main node] (1) {Class: $A$};
            \node[main node] (2) [below of=1] {Class: $B$};
        \end{tikzpicture}
    \end{subfigure}
    \raisebox{1.5cm}{\scalebox{1.5}{$\longrightarrow$}}
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \begin{tikzpicture}[->,auto,node distance=2.5cm,thick,main node/.style={draw}]
            \node[main node] (1) [color=red] {Class: $A$};
            \node[main node] (2) [right of=1, color=blue] {Ind: $A$};
            \node[main node] (3) [below of=2] {Class: $B$};
            \path[every node/.style={font=\sffamily\small}]
            (2) edge [color=blue] node {CI} (3);
        \end{tikzpicture}
    \end{subfigure}
    \caption{Application de la règle $CI(A,B)$}
    \label{fig:rule_ci}
\end{figure}

\gls{setup} donne priorité aux mises à jour, en définissant un ensemble d'effet de bords qui doivent être réalisés pour modifier la base afin de maintenir la cohérence après l'ajout d'un fait.
Les effets de bord sont un ensemble de règle de réécriture construit à partir des règles sémantiques de \gls{rdfs}.
\cite{chabinUsingGraphGrammar2019} propose différents niveaux de modification autorisés.
Ce niveau peut être paramétré pour chaque utilisateur lui donnant ainsi certains droits de modification.
Le niveau le plus élevé est autorisé à modifier le schéma et l'instance pour ajouter un fait.
Un niveau moins élevé permet seulement de modifier l'instance tandis que le niveau le plus bas ne peut pas modifier la base et peut donc seulement ajouter ou supprimer un fait si la cohérence de la base est maintenue.

\begin{example}
    La figure~\ref{fig:app_rule} représente une base de connaissance initiale (en noir) et les modifications nécessaires (en bleu) pour l'ajout du fait $CSub(C_1, C_2)$.
    En suivant les effets de bords figure~\ref{eq:rule_csub}, l'ajout du fait $CSub(C_1, C_2))$ implique que $C_1$ et $C_2$ soient des classes.
    Comme $C_2$ n'est pas présent, le schéma doit être modifié.
    Le fait $CSub(C_2, Resource)$ est alors ajouté.
    Par la suite, le fait $CSub(C_1, C_2))$ peut être ajouté en ajoutant aussi le fait $CI(I, C_2)$ par transitivité de la relation $CI$ (figure~\ref{eq:rule_csub}(\ref{eq:rule_csub:ci})).
    Cet exemple montre l'application d'effets de bords pour rendre applicable une règle.
    Sans ces effets de bords, il aurait été impossible d'ajouter le fait voulu tout en respectant les règles d'intégrités.
    Ici, notre individu est bien l'instance d'une classe et de toutes les sous-classes associées.
    La base avant et après application de la règle est un graphe \gls{rdfs} valide.
\end{example}

\begin{figure}
    \begin{eqnarray*}
        Cl(x)\\
        Cl(y) \lor (y = Resource)\\
        \neg CSub(y, x)\\
        \forall~z CSub(y, z) \to CSub(x, z)\\
        \forall~z CSub(z, x) \to CSub(z, y)\\
        \forall~z_i CI(z_i, x) \to CI(z_i, y) \label{eq:rule_csub:ci}
    \end{eqnarray*}
    \caption{Effets de bord pour l'ajout du fait $CSub(x, y)$}
    \label{eq:rule_csub}
\end{figure}

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}[->,auto,node distance=3cm,thick,main node/.style={draw}]
        \node[main node] (1) {Ind: $I$};
        \node[main node] (2) [above of=1] {Class: $C_1$};
        \node[main node] (3) [right of=1, color=blue] {Class: $C_2$};
        \node[main node] (4) [above of=3] {$Ressource$};
        \path[every node/.style={font=\sffamily\small}]
        (1) edge node [left] {CI} (2)
        (1) edge [color=blue] node [below] {CI} (3)
        (1) edge node [left] {CI} (4)
        (2) edge node [above] {CSub} (4)
        (2) edge [color=blue, distance=4cm, bend right=90] node [below] {CSub} (3)
        (3) edge [color=blue] node [right] {CSub} (4);
    \end{tikzpicture}
    \caption{Exemple de modification pour l'application d'une règle}
    \label{fig:app_rule}
\end{figure}

Une étude menée dans \cite{chabinGraphRewritingSystem2020,chabinGraphRewritingRules2021} montre des temps d'exécution élevée pour l'application des règles sur de petites instances.
Ces performances s'expliquent par le calcul des effets de bords et la grande complexité de la réécriture de graphe.
Cela rend \gls{setup} inutilisable dans un scénario ou des mises à jour arrivent régulièrement.
De plus, l'implémentation actuelle n'a pas de fonctionnalité de type \textit{fallback} permettant d'annuler les changements effectués sur la base en cas d'échec de la mise à jour, si le niveau de l'utilisateur n'est pas suffisant, ce qui implique de travailler sur une copie de la base.
Il reste intéressant pour le calcul mode déconnecté et de petite base du a son implémentation en mémoire primaire.

Bien que \gls{setup} permette la gestion de différents schémas définit sous \gls{rdfs}, il ne permet pas d'ajouter des contraintes métiers.
Définir de nouvelles contraintes impliquerait un travail conséquent et manuel pour leur traduction en règle de réécriture et la construction des effets de bords.
